

# 多程序共享資源

每個程序各有一份自己的資料，默認是無法共享資源。

範例 : 每個程序執行一次 **li.append(i)** 都會擁有個別獨立的資源。

~~~python
from multiprocessing import Process
li = []

def foo(i):
    li.append(i)
    print('say hi', li)
    
if __name__ == '__main__':
    for i in range(10):
        p = Process(target=foo, args=(i,))
        p.start()

    print('ending', li)
~~~

執行結果 :

~~~python
say hi [9]
say hi [7]
say hi [2]
say hi [0]
say hi [8]
say hi [6]
say hi [1]
say hi [5]
say hi [3]
say hi [4]
~~~



## 資源共享方法

### Value

返回一個從共享內存上創建的 **ctypes** 對象，可以通過 *value* 屬性訪問。

範例 : 建立兩個程序共享資源，當子程序執行完畢後，主程序依然可以顯示子程序修改過後所得得到的數值。

~~~python
from multiprocessing import Process, Value, Array

def f(n, a):
    n.value = 3.1415927
    for i in range(len(a)):
        a[i] = -a[i]

if __name__ == '__main__':
    num = Value('d', 0.0) 			# 'd' : double type
    arr = Array('i', range(10))		# 'i' : signed int

    p = Process(target=f, args=(num, arr))
    p.start()
    p.join()

    print(num.value)
    print(arr[:])
~~~

執行結果 :

~~~python
3.1415927
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
~~~



### Manager

Manager() 返回的 manager 提供 list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value and Array類型的支持。

~~~python
from multiprocessing import Process, Manager

def f(d, l):
    d[1] = '1'
    d['2'] = 2
    d[0.25] = None
    l.reverse()

if __name__ == '__main__':
    # 建立兩個共享資源 dict, list
    m = Manager()
    d = m.dict()
    l = m.list(range(10))

    p = Process(target=f, args=(d, l))
    p.start()
    p.join()

    print(d)
    print(l)
~~~

使用 with 方法建立比較容易讀

~~~python
with Manager() as manager: # return a manager instance
    d = manager.dict()
    l = manager.list(range(10))
~~~

執行結果 :

~~~python
{1: '1', '2': 2, 0.25: None}
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
~~~



## 不同程序的資源同步

如果兩個程序需要對共享的資源做修改，這個時候就需要使用鎖，避免數值不正確。

### 使用鎖進行同步

~~~python
import multiprocessing

def job(v, lock):
    with lock:
        print(f'PID: {os.getpid()}')
        for _ in range(5):
            print(v.value, end=",")	# 透過呼 value 方法取值
            v.value += 1
            
def multicore():    
    lock = multiprocessing.Lock()
    v = multiprocessing.Value(ctypes.c_int, 0) # 定義int類型作為共享變數，初始化值為 0
    p1 = multiprocessing.Process(target=job, args=(v, lock))
    p2 = multiprocessing.Process(target=job, args=(v, lock))
    p1.start()
    p2.start()
    p1.join()
    p2.join()

if __name__ == '__main__':
    multicore()          
~~~

執行結果：

~~~python
PID: 9912
0,1,2,3,4,
PID: 10072
5,6,7,8,9,
~~~



### 不使用鎖進行同步

兩個程序對同一個變數做修改，如果不加上鎖，就會導致計算結果不正確

~~~python
def job(v):
    print(f'PID: {os.getpid()}')
    time.sleep(0.1)
    for _ in range(5):
        print(v.value, end=",")	# 透過呼 value 方法取值
        v.value += 1
        
def multicore():
    v = multiprocessing.Value(ctypes.c_int, 0)
    p1 = multiprocessing.Process(target=job, args=(v, lock))
    p2 = multiprocessing.Process(target=job, args=(v, lock))
    p1.start()
    p2.start()
    p1.join()
    p2.join()       
~~~

執行結果：

~~~python
PID: 11824
PID: 9268
0,0,1,2,2,3,3,45,,7,
~~~